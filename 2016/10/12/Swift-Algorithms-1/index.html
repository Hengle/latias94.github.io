<!DOCTYPE html>
<html lang="zh-Hans">
  <head>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">



  <meta name="description" content="Swift 算法查找篇笔记"/>




  <meta name="keywords" content="算法, 未完工, 萤火之森" />



  <meta name="baidu-site-verification" content="BxJt2YcBZH" />








  <link rel="alternate" href="/atom.xml" title="萤火之森">




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.10.2" />



<link rel="canonical" href="http://frankorz.com/2016/10/12/Swift-Algorithms-1/"/>



  <link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />






<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.10.2" />



  
  <script id="baidu_analytics">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?91a6af339098c7b3314fd48d6640bbf8";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>



<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-69634396-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-69634396-1');
</script>


  <script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>





  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
  <script id="leancloud">
    AV.init({
      appId: "v6QgYmEcmbiM4ijI41WdeQSg-gzGzoHsz",
      appKey: "Kfe1eyGyevT3hHuiDfm8Hw1G"
    });
  </script>





<script>
  window.config = {"leancloud":{"app_id":"v6QgYmEcmbiM4ijI41WdeQSg-gzGzoHsz","app_key":"Kfe1eyGyevT3hHuiDfm8Hw1G"},"toc":true,"fancybox":true,"pjax":""};
</script>

    <title> Swift 算法查找篇笔记 - 萤火之森 </title>
  </head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">萤火之森</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    
      <a href="/">
        <li class="mobile-menu-item">
          
          
            首页
          
        </li>
      </a>
    
      <a href="/archives/">
        <li class="mobile-menu-item">
          
          
            归档
          
        </li>
      </a>
    
      <a href="/tags">
        <li class="mobile-menu-item">
          
          
            标签
          
        </li>
      </a>
    
      <a href="/categories">
        <li class="mobile-menu-item">
          
          
            分类
          
        </li>
      </a>
    
      <a href="/books">
        <li class="mobile-menu-item">
          
          
            读书
          
        </li>
      </a>
    
      <a href="/leetcode">
        <li class="mobile-menu-item">
          
          
            LeetCode
          
        </li>
      </a>
    
  </ul>
</nav>

    <div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">萤火之森</a>
</div>

<nav class="site-navbar">
  
    <ul id="menu" class="menu">
      
        <li class="menu-item">
          <a class="menu-item-link" href="/">
            
            
              首页
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/archives/">
            
            
              归档
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/tags">
            
            
              标签
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/categories">
            
            
              分类
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/books">
            
            
              读书
            
          </a>
        </li>
      
        <li class="menu-item">
          <a class="menu-item-link" href="/leetcode">
            
            
              LeetCode
            
          </a>
        </li>
      
    </ul>
  
</nav>

      </header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content">
            
  
  <article class="post">
    <header class="post-header">
      <h1 class="post-title">
        
          Swift 算法查找篇笔记
        
      </h1>

      <div class="post-meta">
        <span class="post-time">
          2016-10-12
        </span>
        
          <span class="post-category">
            
              <a href="/categories/Swift-算法/">Swift 算法</a>
            
          </span>
        
        
        <span class="post-visits"
             data-url="/2016/10/12/Swift-Algorithms-1/"
             data-title="Swift 算法查找篇笔记">
          阅读次数 0
        </span>
        
      </div>
    </header>

    
    
  <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">文章目录</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#大-O-符号"><span class="toc-text">大 O 符号</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linear-Search"><span class="toc-text">Linear Search</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介-1"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能"><span class="toc-text">性能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Binary-Search"><span class="toc-text">Binary Search</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介-2"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码-1"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分而治之"><span class="toc-text">分而治之</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#迭代和递归"><span class="toc-text">迭代和递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最后"><span class="toc-text">最后</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Count-Occurrences"><span class="toc-text">Count Occurrences</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介-3"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#代码-2"><span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Select-Minimum-Maximum"><span class="toc-text">Select Minimum / Maximum</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#最大值或最小值"><span class="toc-text">最大值或最小值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#🌰"><span class="toc-text">🌰</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#代码-3"><span class="toc-text">代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Swift标准库"><span class="toc-text">Swift标准库</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最大值和最小值"><span class="toc-text">最大值和最小值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#🌰-1"><span class="toc-text">🌰</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#代码-4"><span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#k-th-Largest-Element-Problem"><span class="toc-text">k-th Largest Element Problem</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介-4"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#naive-solution"><span class="toc-text">naive solution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#A-faster-solution"><span class="toc-text">A faster solution</span></a></li></ol></li></ol>
    </div>
  </div>



    <div class="post-content">
      
        <blockquote>
<p>未完工<br>尚缺 k-th Largest Element、Selection Sampling、Union-Find</p>
</blockquote>
<p><img src="http://ooo.0o0.ooo/2016/10/12/57fe492d1e042.jpg" alt=""></p>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>这是一系列关于Swift语言的算法笔记，Swift版本为3.0，参考的教程来自 <a href="https://github.com/raywenderlich/swift-algorithm-club" target="_blank" rel="noopener">Swift Algorithms Club</a> 。</p>
<p>所有的代码可以直接在Xcode的Playground中运行，前面的算法较简单，主要说说算法的基础、思路和一些Swift语言的特性，我十分推荐你把这里的算法独自实现一遍。</p>
<p>另外这里可以下载 Swift Algorithms Club 算法教程的Epub文件！ <a href="https://github.com/aquarchitect/swift-algorithm-club/releases/download/1.0.0/SwiftAlgo.epub" target="_blank" rel="noopener">点我下载</a><br><a id="more"></a></p>
<h3 id="大-O-符号"><a href="#大-O-符号" class="headerlink" title="大 O 符号"></a>大 O 符号</h3><p>大O符号（英语：Big O notation）是一种算法复杂度的相对表示方式。</p>
<p>这个句子里有一些重要而严谨的用词：</p>
<ul>
<li><p>相对(relative)：你只能比较相同的事物。你不能把一个做算数乘法的算法和排序整数列表的算法进行比较。但是，比较2个算法所做的算术操作（一个做乘法，一个做加法）将会告诉你一些有意义的东西。</p>
</li>
<li><p>表示(representation)：大O(用它最简单的形式)把算法间的比较简化为了一个单一变量。这个变量的选择基于观察或假设。例如，排序算法之间的对比通常是基于比较操作(比较2个结点来决定这2个结点的相对顺序)。这里面就假设了比较操作的计算开销很大。但是，如果比较操作的计算开销不大，而交换操作的计算开销很大，又会怎么样呢？这就改变了先前的比较方式。</p>
</li>
<li><p>复杂度(complexity)：如果排序10,000个元素花费了我1秒，那么排序1百万个元素会花多少时间？在这个例子里，复杂度就是相对其他东西的度量结果。 </p>
</li>
</ul>
<p>简单地说，O 表示法能给你一个算法的运行时间和它使用的内存量的粗略表示，这两种表示分为时间复杂度和空间复杂度，不过我们通常用 O 来表示时间复杂度，即一个算法执行的快慢。</p>
<table>
<thead>
<tr>
<th>大 O</th>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>O(1)</td>
<td>常数</td>
<td>这是最好的。 该算法不管有多少数据，总是花费相同的时间。 示例：通过索引查找数组的元素。</td>
</tr>
<tr>
<td>O(log n)</td>
<td>对数</td>
<td>特别好。 该算法将每次迭代的数据量减半。 如果你有100个元素，它需要大约7个步骤来找到答案。 有1000个，需要10个步骤。 100万个只需要20步。 即使对于大量的数据，这也是超快的。 示例：二进制搜索。</td>
</tr>
<tr>
<td>O(n)</td>
<td>线性，次线性</td>
<td>很好。 如果你有100个元素，需要100个步骤。 元素个数增加一倍，该算法花费的时间会是两倍。 示例：顺序搜索。</td>
</tr>
<tr>
<td>O(n log n)</td>
<td>线性对数</td>
<td>体面的表现。 这比线性稍差，但不太差。 示例：最快的通用排序算法。</td>
</tr>
<tr>
<td>O(n^2)</td>
<td>平方</td>
<td>有点慢。 如果你有100个元素，要执行100 ^ 2 = 10,000步骤。 加倍的元素数量使其慢四倍（因为2平方等于4）。 示例：使用嵌套循环的算法，如插入排序。</td>
</tr>
<tr>
<td>O(n^3)</td>
<td>立方</td>
<td>很慢。 如果你有100元素，会是100 ^ 3 = 1,000,000步骤。 输入大小加倍使其慢8倍。 示例：矩阵乘法。</td>
</tr>
<tr>
<td>O(2^n)</td>
<td>指数</td>
<td>特别慢。 你想避免这些算法，但有时你没有选择。 添加一个元素就会使运行时间加倍。 示例：<a href="http://baike.baidu.com/view/45957.htm" target="_blank" rel="noopener">旅行推销员问题</a>。</td>
</tr>
<tr>
<td>O(n!)</td>
<td>阶乘</td>
<td>无法忍受的慢。 一百万年也运行不完。</td>
</tr>
</tbody>
</table>
<p><img src="http://ooo.0o0.ooo/2016/10/19/58076cee4c984.png" alt=""></p>
<h3 id="Linear-Search"><a href="#Linear-Search" class="headerlink" title="Linear Search"></a>Linear Search</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>Linear Search，又称线性查找、顺序查找。在给定的数组中，我们会遍历所有的元素，并逐个对比是否与要找的特定元素相等，找到即停止查找，返回特定元素的索引，反之继续遍历对比直至对比完最后一个元素。</p>
<p>目标：从一个数组查找到一个元素</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">linearSearch</span>&lt;T: Equatable&gt;<span class="params">(<span class="number">_</span> array: [T], <span class="number">_</span> object: T)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">  <span class="keyword">for</span> (index, obj) <span class="keyword">in</span> array.enumerated() <span class="keyword">where</span> obj == object &#123;</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放进playground中测试：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line">linearSearch(array, <span class="number">2</span>) <span class="comment">//返回1</span></span><br></pre></td></tr></table></figure>
<p>这是最简单的一个查找了，这里说说Swift的语言特性。</p>
<p><code>&lt;T: Equatable&gt;</code> 中 <code>T</code> 指<a href="http://wiki.jikexueyuan.com/project/swift/chapter2/23_Generics.html" target="_blank" rel="noopener">泛型</a>，而 <code>Equatable</code> 是Swift标准库中定义的一个协议，该协议要求任何遵循该协议的类型必须实现等式符 <code>==</code> 及不等符 <code>!=</code>，从而能对该类型的任意两个值进行比较。所有的 Swift 标准类型自动支持 <code>Equatable</code> 协议。</p>
<p><code>Int?</code> 中的 <code>?</code> 是指返回的值是 <code>Optional</code> 的，如果查找找到值就返回索引值，找不到就返回 <code>nil</code>，<code>Optional</code> 特性让一个值能同时兼容两种情况。</p>
<p><code>enumerated()</code>是一个实例方法，返回的是键值对 <code>(n, x)</code>，n 表示一个连续的从0开始的正整数，x 表示对应的元素。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">for</span> (index, obj) <span class="keyword">in</span> array.enumerated() &#123;<span class="comment">//返回一个 array 拷贝</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="string">"<span class="subst">\(index)</span> -&gt; <span class="subst">\(obj)</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0 -&gt; 5</span></span><br><span class="line"><span class="comment">//1 -&gt; 2</span></span><br><span class="line"><span class="comment">//2 -&gt; 4</span></span><br><span class="line"><span class="comment">//3 -&gt; 7</span></span><br></pre></td></tr></table></figure>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>线性查找的效率是<strong>O(n)</strong><a href="关于大O符号可以参考这里：[维基百科](https://zh.wikipedia.org/wiki/大O符号)">^Big O notation</a>。在最差的情况，我们需要把全部元素都比较一边，最好的情况是我们第一次就查找到相同元素。</p>
<h3 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>Binary Search，就是著名、高效并应用广泛的<strong>二分查找</strong>算法。</p>
<p>目标：快速地从一个数组查找到一个元素</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p>通常情况下，Swift 的<code>indexOf()</code>方法已经足够好了：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">11</span>, <span class="number">59</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">53</span>, <span class="number">17</span>, <span class="number">31</span>, <span class="number">7</span>, <span class="number">19</span>, <span class="number">67</span>, <span class="number">47</span>, <span class="number">13</span>, <span class="number">37</span>, <span class="number">61</span>, <span class="number">29</span>, <span class="number">43</span>, <span class="number">5</span>, <span class="number">41</span>, <span class="number">23</span>]</span><br><span class="line"></span><br><span class="line">numbers.indexOf(<span class="number">43</span>)  <span class="comment">// returns 15</span></span><br></pre></td></tr></table></figure>
<p>内置的<code>indexOf()</code>方法实现了一个线性查找，实现方式类似以下代码：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">linearSearch</span>&lt;T: Equatable&gt;<span class="params">(<span class="number">_</span> a: [T], <span class="number">_</span> key: T)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span> ..&lt; a.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> a[i] == key &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linearSearch(numbers, <span class="number">43</span>)  <span class="comment">// returns 15</span></span><br></pre></td></tr></table></figure>
<p>这代码其实和一开始的线性查找差不多，但是线性查找效率不太高，平均都要搜索半个数组，如果数组足够大，查找将会变得很慢。</p>
<h4 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h4><blockquote>
<p>凡邦之有疾病者，疕疡者造焉，则使医分而治之，是亦不自医也。<br>──清·俞樾《群经平议·周官二》</p>
</blockquote>
<p>分而治之方法与软件设计的模块化方法非常相似。为了解决一个大的问题，可以： </p>
<ol>
<li>把它分成两个或多个更小的问题</li>
<li>分别解决每个小问题</li>
<li>把各小问题的解答组合起来，即可得到原问题的解答。小问题通常与原问题相似，可以递归地使用分而治之策略来解决。</li>
</ol>
<p>在本算法中，我们需要用这策略去不断的拆分数组，直到找到特定元素。另外二分查找的效率是<strong>O(log n)</strong>，也就是对一个有着1,000,000个元素的数组只要将近20步就能找到特定元素，因为<code>log_2(1,000,000) = 19.9</code>，十亿个元素也只需要30步就能完成查找！</p>
<p>听起来爽，但是二分查找有个缺点，就是数组必须是<strong>排序好</strong>的，不过这通常不是一个问题。</p>
<p>二分查找是怎么操作的呢？</p>
<ul>
<li>把排序好的数组平分成两部分，把特定元素与中间键比较，看特定元素应该会在数组左部分（较小）、右部分（较大）或直接相等。</li>
<li>如果在数组左部分，则把数组切剩下左部分，继续进行二分查找。</li>
<li>这里使用了递归，切分的是数组范围<code>range</code></li>
</ul>
<p>先来看看代码吧：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span>&lt;T: Comparable&gt;<span class="params">(<span class="number">_</span> a: [T], key: T, range: Range&lt;Int&gt;)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">if</span> range.lowerBound &gt;= range.upperBound &#123;</span><br><span class="line">        <span class="comment">// 如果经过不断的数组切分，导致范围下界大于等于范围上界，则说明找不到特定元素</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 计算从哪划分数组</span></span><br><span class="line">        <span class="keyword">let</span> midIndex = range.lowerBound + (range.upperBound - range.lowerBound) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果中间键（索引为midIndex）比特定元素大，说明特定元素在数组左部分(range.lowerBound ..&lt; midIndex)</span></span><br><span class="line">        <span class="keyword">if</span> a[midIndex] &gt; key &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(a, key: key, range: range.lowerBound ..&lt; midIndex)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果中间键（索引为midIndex）比特定元素小，说明特定元素在数组右部分(midIndex + 1 ..&lt; range.upperBound)</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> a[midIndex] &lt; key &#123;</span><br><span class="line">            <span class="keyword">return</span> binarySearch(a, key: key, range: midIndex + <span class="number">1</span> ..&lt; range.upperBound)</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果中间键（索引为midIndex）与特定元素相等，说明找到啦！</span></span><br><span class="line">            <span class="keyword">return</span> midIndex</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试1：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>]</span><br><span class="line"></span><br><span class="line">binarySearch(numbers, key: <span class="number">43</span>, range: <span class="number">0</span> ..&lt; numbers.<span class="built_in">count</span>)  <span class="comment">// gives 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要查找的特定元素：43</span></span><br><span class="line"><span class="comment">//第1次查找</span></span><br><span class="line"><span class="comment">//--数组：[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]</span></span><br><span class="line"><span class="comment">//--查找范围：0..&lt;19</span></span><br><span class="line"><span class="comment">//--中间键是：29</span></span><br><span class="line"><span class="comment">//第2次查找</span></span><br><span class="line"><span class="comment">//--数组：[31, 37, 41, 43, 47, 53, 59, 61, 67]</span></span><br><span class="line"><span class="comment">//--查找范围：10..&lt;19</span></span><br><span class="line"><span class="comment">//--中间键是：47</span></span><br><span class="line"><span class="comment">//第3次查找</span></span><br><span class="line"><span class="comment">//--数组：[31, 37, 41, 43]</span></span><br><span class="line"><span class="comment">//--查找范围：10..&lt;14</span></span><br><span class="line"><span class="comment">//--中间键是：41</span></span><br><span class="line"><span class="comment">//第4次查找</span></span><br><span class="line"><span class="comment">//--数组：[43]</span></span><br><span class="line"><span class="comment">//--查找范围：13..&lt;14</span></span><br><span class="line"><span class="comment">//--中间键是：43</span></span><br><span class="line"><span class="comment">//--查找到，索引为13</span></span><br></pre></td></tr></table></figure>
<p>测试2：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>]</span><br><span class="line"></span><br><span class="line">binarySearch(numbers, key: <span class="number">24</span>, range: <span class="number">0</span> ..&lt; numbers.<span class="built_in">count</span>)  <span class="comment">// gives nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//要查找的特定元素：24</span></span><br><span class="line"><span class="comment">//第1次查找</span></span><br><span class="line"><span class="comment">//--数组：[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]</span></span><br><span class="line"><span class="comment">//--查找范围：0..&lt;19</span></span><br><span class="line"><span class="comment">//--中间键是：29</span></span><br><span class="line"><span class="comment">//第2次查找</span></span><br><span class="line"><span class="comment">//--数组：[2, 3, 5, 7, 11, 13, 17, 19, 23]</span></span><br><span class="line"><span class="comment">//--查找范围：0..&lt;9</span></span><br><span class="line"><span class="comment">//--中间键是：11</span></span><br><span class="line"><span class="comment">//第3次查找</span></span><br><span class="line"><span class="comment">//--数组：[13, 17, 19, 23]</span></span><br><span class="line"><span class="comment">//--查找范围：5..&lt;9</span></span><br><span class="line"><span class="comment">//--中间键是：19</span></span><br><span class="line"><span class="comment">//第4次查找</span></span><br><span class="line"><span class="comment">//--数组：[23]</span></span><br><span class="line"><span class="comment">//--查找范围：8..&lt;9</span></span><br><span class="line"><span class="comment">//--中间键是：23</span></span><br><span class="line"><span class="comment">//第5次查找</span></span><br><span class="line"><span class="comment">//--数组：[]</span></span><br><span class="line"><span class="comment">//--查找范围：9..&lt;9</span></span><br><span class="line"><span class="comment">//--找不到！不干了！</span></span><br></pre></td></tr></table></figure>
<p>这其中使用了 <code>Comparable</code> 协议，没有这协议，泛型和其他值是不能比较的， <code>Comparable</code> 协议就是说明<code>T</code>是可比较的。</p>
<p>测试1中用线性查找的话要查找13次，测试2中用线性查找要查找19次，而二分查找分别只用4次和5次就完成查找，能感受算法的威力吗~</p>
<h4 id="迭代和递归"><a href="#迭代和递归" class="headerlink" title="迭代和递归"></a>迭代和递归</h4><p>二分查找是递归的因为我们每次查找都是相同的逻辑，当然用迭代去实现将会更加有效率，因为不需要一次一次地调用函数（考虑下内存空间！）。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span>&lt;T: Comparable&gt;<span class="params">(<span class="number">_</span> a: [T], key: T)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">    <span class="keyword">var</span> lowerBound = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> upperBound = a.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">while</span> lowerBound &lt; upperBound &#123;</span><br><span class="line">        <span class="keyword">let</span> midIndex = lowerBound + (upperBound - lowerBound) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> a[midIndex] == key &#123;</span><br><span class="line">            <span class="keyword">return</span> midIndex</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> a[midIndex] &lt; key &#123;</span><br><span class="line">            lowerBound = midIndex + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            upperBound = midIndex</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> numbers = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>]</span><br><span class="line"></span><br><span class="line">binarySearch(numbers, key: <span class="number">43</span>)  <span class="comment">// gives 13</span></span><br></pre></td></tr></table></figure>
<h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>由于数组必须要先排序，排序和查找的时间加在一起算的话，二分查找耗时可能比顺序查找还多，因此二分查找适合在那种只用排序一次而要查找很多次的情况。</p>
<h3 id="Count-Occurrences"><a href="#Count-Occurrences" class="headerlink" title="Count Occurrences"></a>Count Occurrences</h3><h4 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h4><p>Count Occurrences 就是计数，有时候我们需要计算一个数字出现的次数。当然我们可以用线性查找从头查到尾，这样这种计数的效率是<strong>O(n)</strong>，当然如果我们修改一下二分查找，也能把计数的效率提高到<strong>O(log n)</strong>，别忘了二分查找的条件是数组排序好。</p>
<p>目标：计算一个特定元素在一个<strong>排序好</strong>的数组中出现的次数</p>
<h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countOccurrencesOfKey</span><span class="params">(<span class="number">_</span> key: Int, inArray a: [Int])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">leftBoundary</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> low = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> high = a.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high &#123;</span><br><span class="line">      <span class="keyword">let</span> midIndex = low + (high - low)/<span class="number">2</span></span><br><span class="line">      <span class="keyword">if</span> a[midIndex] &lt; key &#123;</span><br><span class="line">        low = midIndex + <span class="number">1</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        high = midIndex</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">rightBoundary</span><span class="params">()</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> low = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> high = a.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high &#123;</span><br><span class="line">      <span class="keyword">let</span> midIndex = low + (high - low)/<span class="number">2</span></span><br><span class="line">      <span class="keyword">if</span> a[midIndex] &gt; key &#123;</span><br><span class="line">        high = midIndex</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        low = midIndex + <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> rightBoundary() - leftBoundary()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [ <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">11</span> ]</span><br><span class="line"></span><br><span class="line">countOccurrencesOfKey(<span class="number">3</span>, inArray: a)  <span class="comment">// returns 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//右边界第1次查找</span></span><br><span class="line"><span class="comment">//--划分范围后的数组：[0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11]</span></span><br><span class="line"><span class="comment">//--索引为6的中间键：3</span></span><br><span class="line"><span class="comment">//--查找范围：0..&lt;12</span></span><br><span class="line"><span class="comment">//右边界第2次查找</span></span><br><span class="line"><span class="comment">//--划分范围后的数组：[6, 8, 10, 11, 11]</span></span><br><span class="line"><span class="comment">//--索引为9的中间键：10</span></span><br><span class="line"><span class="comment">//--查找范围：7..&lt;12</span></span><br><span class="line"><span class="comment">//右边界第3次查找</span></span><br><span class="line"><span class="comment">//--划分范围后的数组：[6, 8]</span></span><br><span class="line"><span class="comment">//--索引为8的中间键：8</span></span><br><span class="line"><span class="comment">//--查找范围：7..&lt;9</span></span><br><span class="line"><span class="comment">//右边界第4次查找</span></span><br><span class="line"><span class="comment">//--划分范围后的数组：[6]</span></span><br><span class="line"><span class="comment">//--索引为7的中间键：6</span></span><br><span class="line"><span class="comment">//--查找范围：7..&lt;8</span></span><br><span class="line"><span class="comment">//low值为：7</span></span><br><span class="line"><span class="comment">//---------------</span></span><br><span class="line"><span class="comment">//左边界第1次查找</span></span><br><span class="line"><span class="comment">//--划分范围后的数组：[0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11]</span></span><br><span class="line"><span class="comment">//--索引为6的中间键：3</span></span><br><span class="line"><span class="comment">//--查找范围：0..&lt;12</span></span><br><span class="line"><span class="comment">//左边界第2次查找</span></span><br><span class="line"><span class="comment">//--划分范围后的数组：[0, 1, 1, 3, 3, 3]</span></span><br><span class="line"><span class="comment">//--索引为3的中间键：3</span></span><br><span class="line"><span class="comment">//--查找范围：0..&lt;6</span></span><br><span class="line"><span class="comment">//左边界第3次查找</span></span><br><span class="line"><span class="comment">//--划分范围后的数组：[0, 1, 1]</span></span><br><span class="line"><span class="comment">//--索引为1的中间键：1</span></span><br><span class="line"><span class="comment">//--查找范围：0..&lt;3</span></span><br><span class="line"><span class="comment">//左边界第4次查找</span></span><br><span class="line"><span class="comment">//--划分范围后的数组：[1]</span></span><br><span class="line"><span class="comment">//--索引为2的中间键：1</span></span><br><span class="line"><span class="comment">//--查找范围：2..&lt;3</span></span><br><span class="line"><span class="comment">//low值为：3</span></span><br></pre></td></tr></table></figure>
<p><a href="https://gist.github.com/Latias94/3d85a5362ce68998f08310d2c7839efd" target="_blank" rel="noopener">带print版二分查找计数</a></p>
<p>这里使用二分查找方式计数的技巧就是找到特定元素出现的左右边界，当然我们这次要查找的不是特定元素3，而是索引为2的1（左边界）和索引为7的6（右边界）。我们通过不断把左边界和特定元素比较，在第n-1次查找中，范围中的数组upperbound就是左边界，同理右边界在第n-1次查找中，范围中的数组lowerbound就是右边界。如果左边界和右边界都返回0，则代表找不到特定元素。</p>
<p>这是运用算法解决问题的一次实践。</p>
<p>跑个题，我在高中的时候是个小课代表，老师通常会把一叠改好的按学号排序的试卷交给我发放给全班同学。我记得同学各自的学号，查找的时候我会估摸着同学的学号，然后在一叠试卷中的相应位置抽出一张来。不是，放进去，试卷对应的学号小了，我就继续往后估摸位置再抽一张，直到找到为止，这很像二分查找吧！</p>
<h3 id="Select-Minimum-Maximum"><a href="#Select-Minimum-Maximum" class="headerlink" title="Select Minimum / Maximum"></a>Select Minimum / Maximum</h3><h4 id="最大值或最小值"><a href="#最大值或最小值" class="headerlink" title="最大值或最小值"></a>最大值或最小值</h4><p>Select Minimum / Maximum，选择最小值或最大值，也是我们会遇到的情况。</p>
<p>目标：在一个未排序的数组中找到最小值或最大值</p>
<h5 id="🌰"><a href="#🌰" class="headerlink" title="🌰"></a>🌰</h5><p>举个栗子，我们要在一个未排序的数组<code>[ 8, 3, 9, 4, 6 ]</code>中找到最大值。</p>
<ol>
<li>找到第一个元素<code>8</code>，存储为最大值</li>
<li>找到下一个元素<code>3</code>，比较现有最大值<code>8</code>，3&lt;8，所以最大值<code>8</code>不变</li>
<li>找到下一个元素<code>9</code>，比较现有最大值<code>8</code>，9&gt;8，所以最大值赋值为<code>9</code></li>
<li>重复步骤直到所有元素遍历一遍</li>
</ol>
<p>最小值和以上步骤类似，每次储存较小值即可。</p>
<h5 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimum</span>&lt;T: Comparable&gt;<span class="params">(<span class="number">_</span> a: [T])</span></span> -&gt; <span class="type">T</span>? &#123; </span><br><span class="line">  <span class="comment">//本来swift2的写法是(var a:[T])直接定义一个可变数组..3.0不可用</span></span><br><span class="line">  <span class="keyword">var</span> array = a </span><br><span class="line">  <span class="keyword">guard</span> !array.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//如果数组不是不空，就不返回 nil....</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> minimum = array.removeFirst()</span><br><span class="line">  <span class="keyword">for</span> element <span class="keyword">in</span> array &#123;</span><br><span class="line">    minimum = element &lt; minimum ? element : minimum</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> minimum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maximum</span>&lt;T: Comparable&gt;<span class="params">(<span class="number">_</span> array: [T])</span></span> -&gt; <span class="type">T</span>? &#123;</span><br><span class="line">  <span class="keyword">var</span> array = a</span><br><span class="line">  <span class="keyword">guard</span> !array.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> maximum = array.removeFirst()</span><br><span class="line">  <span class="keyword">for</span> element <span class="keyword">in</span> array &#123;</span><br><span class="line">    maximum = element &gt; maximum ? element : maximum</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> maximum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [ <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">6</span> ]</span><br><span class="line">minimum(array)   <span class="comment">// return 3</span></span><br><span class="line">maximum(array)   <span class="comment">// return 9</span></span><br></pre></td></tr></table></figure>
<h5 id="Swift标准库"><a href="#Swift标准库" class="headerlink" title="Swift标准库"></a>Swift标准库</h5><p>然而 Swift 标准库已经给我们提供了查最大值或最小值的方法<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [ <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">6</span> ]</span><br><span class="line">array.<span class="built_in">min</span>()   <span class="comment">// This will return 3</span></span><br><span class="line">array.<span class="built_in">max</span>()		<span class="comment">// This will return 9</span></span><br></pre></td></tr></table></figure></p>
<h4 id="最大值和最小值"><a href="#最大值和最小值" class="headerlink" title="最大值和最小值"></a>最大值和最小值</h4><p>如果我们要同时查找最大值和最小值呢？</p>
<h5 id="🌰-1"><a href="#🌰-1" class="headerlink" title="🌰"></a>🌰</h5><p>如果我们要同时在一个未排序的数组<code>[ 8, 3, 9, 6, 4 ]</code>同时查找最大值和最小值，我们需要两两比较其中的元素。</p>
<ol>
<li>找到第一个元素<code>8</code>，同时存储为最大值和最小值</li>
<li>由于数组中有奇数个数组，当移除元素<code>8</code>之后，剩下<code>[3, 9]</code>和<code>[6, 4]</code>这两对子数组</li>
<li>在第一个子数组<code>[3, 9]</code>中，比较两数大小。<code>3</code>较小，与当前最小值<code>8</code>比较，3&lt;8，因此把最小值赋值为<code>3</code>。<code>9</code>较大，与当前最大值<code>8</code>比较，9&gt;8，因此把最大值赋值为<code>9</code>。</li>
<li>第二个子数组<code>[6, 4]</code>中，比较两数大小。<code>4</code>较小，与当前最小值<code>3</code>比较，4&gt;3，因此最小值不变。<code>6</code>较大，与当前最大值<code>9</code>比较，6&lt;9，因此最大值不变。</li>
<li>最大值为9，最小值为3。</li>
</ol>
<h5 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h5><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimumMaximum</span>&lt;T: Comparable&gt;<span class="params">(<span class="number">_</span> a: [T])</span></span> -&gt; (minimum: <span class="type">T</span>, maximum: <span class="type">T</span>)? &#123;</span><br><span class="line">  <span class="keyword">var</span> array = a</span><br><span class="line">  <span class="keyword">guard</span> !array.isEmpty <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> minimum = array.first!</span><br><span class="line">  <span class="keyword">var</span> maximum = array.first!</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> hasOddNumberOfItems = array.<span class="built_in">count</span> % <span class="number">2</span> != <span class="number">0</span></span><br><span class="line">  <span class="keyword">if</span> hasOddNumberOfItems &#123;</span><br><span class="line">    array.removeFirst()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> !array.isEmpty &#123;</span><br><span class="line">    <span class="keyword">let</span> pair = (array.removeFirst(), array.removeFirst())</span><br><span class="line">    <span class="keyword">if</span> pair.<span class="number">0</span> &gt; pair.<span class="number">1</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> pair.<span class="number">0</span> &gt; maximum &#123;</span><br><span class="line">        maximum = pair.<span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> pair.<span class="number">1</span> &lt; minimum &#123;</span><br><span class="line">        minimum = pair.<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> pair.<span class="number">1</span> &gt; maximum &#123;</span><br><span class="line">        maximum = pair.<span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> pair.<span class="number">0</span> &lt; minimum &#123;</span><br><span class="line">        minimum = pair.<span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (minimum, maximum)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> array = [ <span class="number">8</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">6</span> ]</span><br><span class="line"><span class="keyword">let</span> result = minimumMaximum(array)!</span><br><span class="line">result.minimum   <span class="comment">// This will return 3</span></span><br><span class="line">result.maximum   <span class="comment">// This will return 9</span></span><br></pre></td></tr></table></figure></p>
<p><code>hasOddNumberOfItems</code>确保数组一直能够被两两分组，实际上数组元素在 while 循环中一直在被两个两个地 remove，同时在做比较大小并赋大小值。</p>
<h3 id="k-th-Largest-Element-Problem"><a href="#k-th-Largest-Element-Problem" class="headerlink" title="k-th Largest Element Problem"></a>k-th Largest Element Problem</h3><h4 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h4><p>k-th Largest Element Problem，是查找一个数组中第 k 个较大的元素的问题。</p>
<p>例如，第一个较大的元素是数组中的最大值，如果数组有 n 个元素，那么第 n 个较大的元素就是该数组的最小值，中位数就是第 n/2 个较大的元素。</p>
<h4 id="naive-solution"><a href="#naive-solution" class="headerlink" title="naive solution"></a>naive solution</h4><p>下面的算法是 semi-naive (较幼稚..?)的，从第一次排序好数组后，时间复杂度为<code>O(n log n)</code>，并且额外用了 O(n)的空间复杂度。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthLargest</span><span class="params">(a: [Int], k: Int)</span></span> -&gt; <span class="type">Int</span>? &#123;</span><br><span class="line">  <span class="keyword">let</span> len = a.<span class="built_in">count</span></span><br><span class="line">  <span class="keyword">if</span> k &gt; <span class="number">0</span> &amp;&amp; k &lt;= len &#123;</span><br><span class="line">    <span class="keyword">let</span> sorted = a.<span class="built_in">sort</span>()</span><br><span class="line">    <span class="keyword">return</span> sorted[len - k]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在这方法中，<code>a</code> 是接受输入的数组，<code>k</code> 是返回第 k 个较大的数。</p>
<p>举个例子，设 <code>k = 4</code>，输入数组为<br><code>[ 7, 92, 23, 9, -1, 0, 11, 6 ]</code><br>一开始没有直接的办法去找第 k 个较大的数，首先我们需要排序好数组。<br><code>[ -1, 0, 6, 7, 9, 11, 23, 92 ]</code><br>现在我们需要拿到索引为<code>a.count - k</code>的元素。<br><code>a[a.count - k] = a[8 - 4] = a[4] = 9</code><br>当然了，如果要找第 k 个较小的数，我们会用<code>a[k]</code>。</p>
<h4 id="A-faster-solution"><a href="#A-faster-solution" class="headerlink" title="A faster solution"></a>A faster solution</h4><p>这里有一种结合了二分查找和快速排序的算法，时间复杂度能达到 <code>O(n)</code>。</p>
<p>还记得二分查找不断的划分一半数组吗？这样能快速地靠近要查找的元素，这里我们也需要这么做。</p>
<p>快速排序也划分数组，它把所有较小的元素移到中轴的左边，较大的元素放在右边。</p>

      
    </div>

    
      
      

  <div class="post-copyright">
    <p class="copyright-item">
      <span>原文作者: </span>
      <a href="http://frankorz.com">猫冬</a>
    </p>
    <p class="copyright-item">
      <span>原文链接: </span>
      <a href="http://frankorz.com/2016/10/12/Swift-Algorithms-1/">http://frankorz.com/2016/10/12/Swift-Algorithms-1/</a>
    </p>
    <p class="copyright-item">
      <span>许可协议: </span>
      
      <a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>



      
      
    

    
      <footer class="post-footer">
        
          <div class="post-tags">
            
              <a href="/tags/算法/">算法</a>
            
              <a href="/tags/未完工/">未完工</a>
            
          </div>
        
        
        
  <nav class="post-nav">
    
      <a class="prev" href="/2016/10/17/powerful-jsonexport/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">用JSONExport一键生成JSON Model</span>
        <span class="prev-text nav-mobile">上一篇</span>
      </a>
    
    
      <a class="next" href="/2016/10/06/proxy-methods/">
        <span class="next-text nav-default">macOS 代理解决方案</span>
        <span class="prev-text nav-mobile">下一篇</span>
        <i class="iconfont icon-right"></i>
      </a>
    
  </nav>


      </footer>
    

  </article>


          </div>
          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
      </main>

      <footer id="footer" class="footer">

  <div class="social-links">
    
      
        
          <a href="mailto:frankorz@qq.com" class="iconfont icon-email" title="email"></a>
        
      
    
      
    
      
    
      
    
      
    
      
    
      
        
          <a href="https://github.com/Latias94" class="iconfont icon-github" title="github"></a>
        
      
    
      
        
          <a href="http://weibo.com/u/1825527674" class="iconfont icon-weibo" title="weibo"></a>
        
      
    
      
        
          <a href="https://www.zhihu.com/people/zhuang-ming-zhen" class="iconfont icon-zhihu" title="zhihu"></a>
        
      
    
      
    
      
    
      
    

    
      <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    
  </div>



<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://hexo.io/">Hexo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>
  <span class="division">|</span>
  <span class="host-by">
    Hosted by <a class="hexo-link" href="https://coding.net/pages">Coding Pages</a>
  </span>
  <span class="copyright-year">
    
    &copy; 
     
      2015 - 
    
    2019

    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">猫冬</span>
  </span>
</div>

      </footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div>

    
  
  <script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://frankorz.com/2016/10/12/Swift-Algorithms-1/';
        this.page.identifier = '2016/10/12/Swift-Algorithms-1/';
        this.page.title = 'Swift 算法查找篇笔记';
    };
    (function() {
    var d = document, s = d.createElement('script');

    s.src = '//frankorz.disqus.com/embed.js';

    s.setAttribute('data-timestamp', +new Date());
    (d.head || d.body).appendChild(s);
    })();  
  </script>

  

  



    
  







  
    <script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  

  
    <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  

  
    <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  

  

  


    <script type="text/javascript" src="/js/src/even.js?v=2.10.2"></script>

  <script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618},"display":{"superSample":2,"width":120,"height":240,"position":"left","hOffset":0,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
